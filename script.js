console.clear();

let qr = [
[
true,
true,
true,
true,
true,
true,
true,
false,
false,
true,
false,
true,
true,
false,
true,
true,
false,
false,
true,
true,
false,
false,
true,
true,
true,
true,
true,
true,
true],

[
true,
false,
false,
false,
false,
false,
true,
false,
false,
false,
true,
true,
true,
false,
false,
true,
true,
true,
true,
false,
true,
false,
true,
false,
false,
false,
false,
false,
true],

[
true,
false,
true,
true,
true,
false,
true,
false,
false,
true,
false,
true,
true,
false,
true,
false,
false,
true,
true,
true,
true,
false,
true,
false,
true,
true,
true,
false,
true],

[
true,
false,
true,
true,
true,
false,
true,
false,
false,
true,
true,
false,
false,
true,
false,
false,
false,
false,
true,
false,
false,
false,
true,
false,
true,
true,
true,
false,
true],

[
true,
false,
true,
true,
true,
false,
true,
false,
false,
true,
true,
true,
true,
false,
true,
false,
true,
false,
true,
false,
false,
false,
true,
false,
true,
true,
true,
false,
true],

[
true,
false,
false,
false,
false,
false,
true,
false,
true,
true,
false,
true,
true,
false,
false,
true,
false,
false,
false,
true,
false,
false,
true,
false,
false,
false,
false,
false,
true],

[
true,
true,
true,
true,
true,
true,
true,
false,
true,
false,
true,
false,
true,
false,
true,
false,
true,
false,
true,
false,
true,
false,
true,
true,
true,
true,
true,
true,
true],

[
false,
false,
false,
false,
false,
false,
false,
false,
false,
false,
false,
false,
false,
true,
false,
true,
false,
true,
true,
false,
true,
false,
false,
false,
false,
false,
false,
false,
false],

[
true,
false,
false,
true,
false,
true,
true,
false,
true,
false,
true,
false,
false,
false,
true,
false,
true,
false,
false,
false,
false,
true,
false,
true,
false,
false,
false,
false,
false],

[
false,
false,
false,
false,
false,
false,
false,
false,
false,
true,
false,
true,
false,
true,
false,
false,
true,
false,
false,
false,
true,
false,
true,
false,
false,
true,
false,
false,
true],

[
false,
true,
false,
false,
true,
false,
true,
true,
true,
false,
false,
true,
false,
true,
true,
false,
true,
false,
true,
true,
false,
false,
false,
true,
true,
true,
true,
true,
false],

[
false,
true,
true,
true,
false,
false,
false,
true,
true,
false,
true,
true,
false,
true,
false,
true,
false,
false,
true,
true,
false,
true,
false,
true,
false,
false,
true,
true,
false],

[
true,
true,
true,
true,
false,
true,
true,
true,
true,
false,
false,
true,
false,
false,
true,
false,
false,
true,
true,
true,
true,
true,
true,
false,
false,
true,
false,
true,
true],

[
true,
false,
false,
false,
true,
false,
false,
true,
false,
true,
false,
false,
false,
true,
true,
false,
false,
false,
false,
true,
true,
true,
false,
false,
false,
false,
false,
false,
false],

[
true,
false,
true,
false,
false,
false,
true,
false,
true,
false,
false,
true,
false,
true,
true,
false,
false,
false,
false,
false,
true,
true,
true,
true,
true,
true,
true,
true,
true],

[
true,
false,
true,
true,
true,
false,
false,
false,
false,
false,
true,
true,
false,
false,
false,
false,
true,
true,
true,
false,
true,
false,
false,
false,
false,
true,
false,
true,
false],

[
true,
false,
true,
false,
true,
false,
true,
true,
false,
true,
false,
true,
false,
true,
false,
false,
true,
true,
false,
false,
true,
true,
false,
false,
false,
false,
false,
true,
false],

[
false,
false,
false,
true,
true,
false,
false,
false,
false,
false,
true,
true,
false,
true,
true,
true,
true,
false,
true,
false,
true,
true,
true,
true,
false,
true,
false,
false,
true],

[
true,
false,
true,
false,
true,
true,
true,
true,
true,
true,
false,
false,
true,
false,
true,
false,
true,
false,
true,
false,
false,
true,
false,
true,
false,
false,
false,
true,
true],

[
false,
false,
true,
true,
true,
true,
false,
false,
true,
false,
false,
false,
false,
false,
true,
true,
true,
true,
false,
true,
true,
true,
false,
false,
true,
false,
false,
true,
true],

[
true,
false,
false,
true,
true,
true,
true,
false,
true,
false,
false,
false,
false,
false,
false,
true,
false,
false,
false,
true,
true,
true,
true,
true,
true,
false,
true,
false,
false],

[
false,
false,
false,
false,
false,
false,
false,
false,
true,
true,
false,
true,
true,
false,
true,
false,
true,
true,
false,
true,
true,
false,
false,
false,
true,
false,
true,
true,
true],

[
true,
true,
true,
true,
true,
true,
true,
false,
false,
true,
false,
true,
false,
false,
false,
false,
true,
false,
false,
false,
true,
false,
true,
false,
true,
false,
false,
true,
false],

[
true,
false,
false,
false,
false,
false,
true,
false,
true,
false,
true,
false,
true,
false,
true,
true,
true,
false,
true,
false,
true,
false,
false,
false,
true,
true,
true,
false,
false],

[
true,
false,
true,
true,
true,
false,
true,
false,
false,
true,
true,
false,
true,
false,
false,
false,
true,
true,
false,
false,
true,
true,
true,
true,
true,
false,
false,
true,
true],

[
true,
false,
true,
true,
true,
false,
true,
false,
true,
false,
false,
false,
true,
true,
false,
true,
false,
false,
false,
true,
false,
true,
true,
true,
true,
true,
true,
true,
false],

[
true,
false,
true,
true,
true,
false,
true,
false,
false,
false,
false,
true,
true,
true,
false,
false,
false,
false,
false,
false,
true,
false,
false,
false,
true,
true,
true,
false,
true],

[
true,
false,
false,
false,
false,
false,
true,
false,
false,
true,
true,
false,
false,
false,
false,
false,
true,
true,
false,
true,
true,
false,
true,
false,
true,
false,
false,
true,
false],

[
true,
true,
true,
true,
true,
true,
true,
false,
true,
false,
true,
false,
false,
true,
false,
true,
false,
true,
true,
false,
true,
false,
true,
false,
true,
true,
false,
true,
false]];



function addPaddingToQRArray(padding, arr) {
  let arrCopy = [...arr];

  for (let i = 0; i < arrCopy.length; i++) {
    for (let j = 0; j < padding; j++) {
      arrCopy[i].unshift(false);
      arrCopy[i].push(false);
    }
  }

  const emptyRow = [...arrCopy[0].map(e => false)];

  for (let i = 0; i < padding; i++) {
    arrCopy.unshift(emptyRow);
    arrCopy.push(emptyRow);
  }

  return arrCopy;
}

const newqr = addPaddingToQRArray(8, qr);
const qrflat = newqr.flat();
const gradient = (n, width = 10, gradientWidth = 3) => [Math.min(Math.abs(n % width) / gradientWidth, 1), Math.min((width - n % width) / gradientWidth, 1)];


const pixelSize = 15;
let cols = newqr[0].length;
let rows = newqr.length;
let neighbourhood = 3;

const wrapNumber = (n, max) => (max + n % max) % max;

const createGrid = (
cols,
rows,
cellFn = (d, i) => ({ alive: true })) =>

new Array(cols * rows).fill('').map(cellFn);


const coordToIndex = (
x,
y,
cols = 10,
rows = 10) =>
wrapNumber(y, rows) * cols + wrapNumber(x, cols);

const indexToCoord = (
index,
cols = 10,
rows = 10) =>
[
index % cols,
Math.floor(index / cols)];


let grid, nextGrid;

function setup() {
  createCanvas(cols * pixelSize, rows * pixelSize);

  grid = createGrid(
  cols, rows, (d, i) => ({
    alive: qrflat[i],
    age: 0,
    position: indexToCoord(i, cols, rows) }));



  noStroke();

  nextGrid = [...grid];
  background(0);
  frameRate(33);
};

let start = false;
function mouseClicked() {
  start = !start;
}

function draw() {

  /*
    Any live cell with two or three live neighbours survives.
    Any dead cell with three live neighbours becomes a live cell.
    All other live cells die in the next generation. Similarly, all other dead cells stay dead.
  */

  if (start) {
    grid.forEach((ge, i) => {
      let sum = 0;

      const pos = ge.position;

      for (let x = -1; x <= 1; x++) {
        for (let y = -1; y <= 1; y++) {

          let isBorder = false;

          if (pos[0] + x < cols && pos[0] + x > -1 && pos[1] + y > -1 && pos[1] + y < rows) {
            isBorder = true;
          }

          isBorder = true;

          let index = coordToIndex(
          pos[0] + x,
          pos[1] + y,
          cols,
          rows);


          sum += grid[
          index].
          alive && isBorder ? 1 : 0;
        }
      }

      const wasAlive = ge.alive;

      if (ge.alive == false && sum == 3) {
        nextGrid[i].alive = true;
      } else if (ge.alive == true && (sum > 4 || sum < 3)) {
        nextGrid[i].alive = false;
      } else {
        nextGrid[i].alive = ge.alive;
      }

      nextGrid[i].age = wasAlive && nextGrid[i].alive ? nextGrid[i].age + 1 : 0;
    });

  }
  nextGrid.forEach((ge, i) => {
    const pos = ge.position;

    const leftIndex = coordToIndex(
    pos[0] - 1,
    pos[1],
    cols, rows);


    const topIndex = coordToIndex(
    pos[0],
    pos[1] - 1,
    cols, rows);


    const rightIndex = coordToIndex(
    pos[0] + 1,
    pos[1],
    cols, rows);


    const bottomIndex = coordToIndex(
    pos[0],
    pos[1] + 1,
    cols, rows);


    /*
    
    const gradientX = gradient(pos[0], cols, 4);
    const gradientY = gradient(pos[1], rows, 4);
    
    let opacity = Math.max(
      Math.min(gradientX[0], gradientX[1]),
      Math.min(gradientY[0], gradientY[1])
    );
    
    */

    /*
    fill(ge.alive ? `hsla(${
      (180 + Math.floor(ge.age) * -20) % 360
    }, 100%, 80%, 1)` : `rgba(0,0,0,.3)`);
    */
    const age = Math.min(ge.age, 7) / 7;
    fill(ge.alive ? `rgb(${age * 255},${(1 - age) * 255},255)` : `rgba(0,0,0,.3)`);


    rect(
    pos[0] * pixelSize, // x
    pos[1] * pixelSize, // y
    pixelSize, // w
    pixelSize, // h
    !grid[leftIndex].alive && !grid[topIndex].alive ? pixelSize : 0,
    !grid[topIndex].alive && !grid[rightIndex].alive ? pixelSize : 0,
    !grid[rightIndex].alive && !grid[bottomIndex].alive ? pixelSize : 0,
    !grid[leftIndex].alive && !grid[bottomIndex].alive ? pixelSize : 0);


    if (
    !grid[leftIndex].alive && !grid[topIndex].alive &&
    !grid[topIndex].alive && !grid[rightIndex].alive &&
    !grid[rightIndex].alive && !grid[bottomIndex].alive &&
    !grid[leftIndex].alive && !grid[bottomIndex].alive)
    {
      fill(0);

      circle(
      pixelSize * .5 + pos[0] * pixelSize, // x
      pixelSize * .5 + pos[1] * pixelSize, // y
      ge.age * pixelSize * .1, // w
      ge.age * pixelSize * .1 // h
      );
    }

    // copy to new genereration
    grid[i].alive = ge.alive;
  });

}